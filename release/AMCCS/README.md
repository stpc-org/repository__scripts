                   
# 使用说明书 | Instruction

## 高级多联装火炮控制系统 | Advanced Multiple Cannon Control System

> AMCCS | Version 0.1.6 | by SiriusZ-BOTTLE  
> STPC旗下SCPT脚本工作室开发 欢迎加入STPC  
> **STPC主群群号(QQ):320461590** **我们欢迎新朋友**  

## 目录 | Catalog
<!-- [TOC] -->

- [使用说明书 | Instruction](#使用说明书--instruction)
  - [高级多联装火炮控制系统 | Advanced Multiple Cannon Control System](#高级多联装火炮控制系统--advanced-multiple-cannon-control-system)
  - [目录 | Catalog](#目录--catalog)
  - [傻瓜式手册](#傻瓜式手册)
  - [脚本功能](#脚本功能)
  - [使用方法](#使用方法)
  - [脚本参数](#脚本参数)
  - [脚本选项](#脚本选项)
  - [LCD配置](#lcd配置)
  - [信息显示](#信息显示)
  - [注意事项](#注意事项)
  - [更新日志](#更新日志)
  - [实用参数记录](#实用参数记录)

## 傻瓜式手册
> 如果你只想使用此脚本的核心能, 并且懒得看复杂的说明文档, 请看这里, 其它都可不看  
> 请注意, 按此步骤设置则采用脚本默认选项, 这通常可用于大多数常规的 (机枪分离) 火炮, 但仍不能保证适用于所有火炮  

1. 在网格上面放置一个编程块, 把脚本的所有内容粘贴进去, 点确定
2. 把你的第一根火炮的蓄力活塞编组为 "Pistons_cannon_#0"(勿带双引号, 下同),  
    第二根的活塞编组为 "Pistons_cannon_#1", 以此类推
3. 把你的第一根火炮的释放转子编组为 "Releasers_cannon_#0" ...以此类推...
4. 把你的第一根火炮的分离加特林编组为 "Detachers_cannon_#0" ...以此类推...
5. 如果你有三根炮, 就在选项里面把 index__cannon_end 设置成 2, 两根就设为 1,  
    ...以此类推... 请注意, 脚本默认是从 0 开始计数的! 
6. 设置完成之后需要在编程块中重置脚本一次, 最后在工具栏中添加该编程块,  
    找到并点击 "运行" 条目, SE会提示你输入运行参数, 键入 "fire" , 点确定
7. 接下来触发上一个步骤中添加到工具栏中的项目就可以开火了!!!


## 脚本功能

1. 任意数量 (最多1000) 的**火炮的基础管理**, 如射击, 装填, 激活炮弹等等
2. 本脚本**自定义程度极高**, 完全标准化和通用化, 可自行配置选项以支持各种不同的火炮(几乎支持全部活塞火炮).
3. **自检功能**, 脚本可以自动识别并维护任意数量火炮的运行状态, 脚本会自动停用或者尝试重新复位被检测为故障的火炮,
    脚本识别的两种火炮故障类型: 
    1. 火炮本身的元件被检测出无法工作 (可能是因为关键元件被关闭, 或元件耐久低于阈值 (俗称血条红了)).  
    2. 火炮蓄力元件 (通常是活塞) 没有成功附着并蓄力, 此时脚本能够尝试自动重新装载火炮 (可在脚本选项中开关此功能).  
    自动检查频率 (周期) 也可在脚本选项中配置.
    
4. **脚本支持自动射击**, 通过特定参数运行脚本一次可以开关此功能, 自动射击的频率 (周期) 可在脚本选项中配置.
5. **脚本支持LCD信息显示**, 脚本可以获取特定编组内的全部LCD显示器, 并且根据其自定义数据显示不同的信息, 
    输出信息的刷新频率 (周期) 可在脚本选项中配置.
    
6. **火炮编组功能**, 脚本支持将数门火炮编入一个组内, 实现高级编组管理.
7. **火炮高级保险**, 脚本支持弹头安全锁, 同时会检查炮弹是否成功分离. 还可自动设置弹头倒计时.
8. 脚本提供**自定义定时器接口**, 可以通过设置自定义定时器来实现一些更加细致的火炮动作 (如火炮状态指示灯等等).
9. 脚本目前支持**两个运行模式**: 常规模式和武器同步模式, 适应绝大多数场景.
10. 脚本支持二段蓄力结构的新式活塞火炮, 由于此功能较为复杂, 如果需要使用该功能请联系作者 (请先进群).
11. V0.2.0版本之后新增了炮弹 (分离) 网格完整性检查, 大幅增加火炮可靠性, 此选项可以开关.


## 使用方法

1. 在网格上面放置一个编程块, 把脚本的所有内容粘贴进去, 点击确定之后脚本开始进行初始化  
2. 脚本会自动在其所在的编程块的自定义数据中生成脚本配置选项, 通过修改这些配置可以高度自定义脚本的行为  
3. 在脚本选项中设置你想让本脚本管理的活塞火炮编号范围  
    ```
    <举例> 
    如果设置 index__cannon_begin = 0, index__cannon_end = 2, 
    则脚本控制的火炮为0号, 1号和2号. 如果都设为0则只控制0号
    ```
    
4. 将你的活塞炮的核心元件和一些可选功能的元件按照脚本指定的名称(可在脚本选项中修改)进行编组  
    有关脚本配置选项的说明, 请查阅 [脚本选项](#脚本选项) 主题
    ```
    <举例> 
    如果设置 tag__cannon_pistons_group = "Pistons_#", 则第0号火炮的活塞编组名应该是 Pistons_#0, 
    第1号火炮的活塞编组名应该是 Pistons_#1, 本脚本完全依赖编组名称的编号后缀来区分不同编号火炮的同类型组件, 
    同样的, 若设置 tag__cannon_detachers_group = Gatlins_#, 则第2号火炮的炮弹分离器编组名应该是 Gatlins_#2.
    ```
    
5. 如果你顺利地完成了以上步骤并运行了 (重置代码) 脚本, 此时在编程块的终端中将会显示一些信息,  
    这些信息能够提示你脚本的运行状态, 比如, 火炮的运行状态等等, 详情请查阅 [信息显示](#信息显示) 主题
    
6. 当脚本能够正常地识别你的火炮之后, 使用参数运行脚本就可以控制你的火炮了, 详情请查阅 [脚本参数](#脚本参数) 主题
7. 最后, 若你想让作品看起来更加炫酷一些, 让脚本将信息实时输出到LCD显示器上会是个不错的选择,  
    你只需要将LCD按照脚本指定的方式 (可在脚本选项中修改) 编组, 脚本就能根据你在LCD中输入的自定义数据,  
    在对应的LCD上显示不同的信息. 有关脚本支持的LCD自定义数据, 请查阅 [LCD配置](#lcd配置) 主题  


## 脚本参数
> 使用这些参数运行脚本以控制脚本执行对应功能

|                指令                |                  功能说明                   | 参数  |                      备注                       |
| :--------------------------------: | :-----------------------------------------: | :---: | :---------------------------------------------: |
|             **`fire`**             |                进行一次射击                 |  无   |           齐射或轮射, 默认是轮射模式            |
|             **`fire`**             |        编号为 `m` 的编组进行一次射击        |  `m`  |            会检查边界, 但无越界提示             |
|       (空字符串, 什么都不写)       |                进行一次射击                 |  无   | 齐射或轮射, 默认是轮射模式 (同无参 **`fire`** ) |
|            **`fire_S`**            | 编号为 `m` 的编组进行一次射击(指定射击模式) |  `m`  |     编组进行齐射. 会检查边界, 但无越界提示      |
|            **`fire_R`**            | 编号为 `m` 的编组进行一次射击(指定射击模式) |  `m`  |     编组进行轮射. 会检查边界, 但无越界提示      |
|           **`fire_SS`**            |         进行一次射击(指定射击模式)          |  无   |    S指齐射, 这里指组间和组内均以齐射模式射击    |
|           **`fire_SR`**            |         进行一次射击(指定射击模式)          |  无   |        R指轮射, 这里指组间齐射, 组内轮射        |
|           **`fire_RS`**            |         进行一次射击(指定射击模式)          |  无   |         同理, 这里指组间轮射, 组内齐射          |
|           **`fire_RR`**            |         进行一次射击(指定射击模式)          |  无   |    R指轮射, 这里指组间和组内均以轮射模式射击    |
| **`toggle_inter_group_fire_mode`** |            脚本切换组间射击模式             |  无   |                                                 |
| **`toggle_intra_group_fire_mode`** |            脚本切换组内射击模式             |  无   |                                                 |
|    **`toggle_auto_fire_onoff`**    |              脚本开关自动射击               |  无   | 自动射击相当于以固定的频率执行 **`fire`** 参数  |
|     **`check_cannons_status`**     |        脚本强制执行一次火炮状态检查         |  无   |   将检查全部火炮, 大部分情况下无需使用此指令    |

注: 
1. 指令后如果需要带参数请使用空格进行分隔, 如有多个参数每个参数之间都需要至少一个空格

## 脚本选项
> 选项很多, 这是为了实现标准化...不过, 如果你用的是常规火炮, 其中大部分并不用修改, 默认就好

1. **`mode_script`** 脚本全局运行模式, 一般来讲不需要修改
    ```
    脚本的运行模式默认是 Regular, 也即常规模式, 这种模式下, 脚本会响应 fire 命令. 
    该项的另一个有效值是 WeaponSync, 即, 武器同步模式, 此模式下, 脚本不响应 fire 命令,
    脚本会为每一个火炮编组查找以指定方式命名的用于同步的武器编组, 
    若检测到编组内有武器方块(火箭发射器或加特林机枪)处于射击状态, 
    那么脚本会控制相应的编组进行射击, 也可将其理解为武器绑定模式.
    ```

2. **`index__cannon_begin`**                   (重要) 脚本控制的火炮的起始编号(含)
3. **`index__cannon_end`**                     (重要) 脚本控制的火炮的末尾编号(含)
    ```
    <举例> 
    若 index__cannon_begin = 0, index__cannon_end = 5, 
    此时脚本就知道你要控制的火炮有 0 1 2 3 4 5 一共六门. 
    ```

4. **`number__cannons_in_group`**              (重要) 一个编组内的火炮数量
    ```
    若 number__cannons_in_group = 0, 则无论有多少门炮, 都会置入一个编组, 
    若 number__cannons_in_group = m, 其中 m 不等于0 , 则脚本会按顺序, 
    将火炮放入编组中, 每个编组 m 个火炮, 对于火炮数量不可整除 m 的情况
    最后一个编组的火炮数量会低于 m
    ```
    ```
    <举例> 
    若有 0 1 2 3 4 5 六门火炮, 且 number__cannons_in_group = 4, 
    则 0 1 2 3 为0号编组, 4 5 为1号编组. 
    ```

5. **`tag__cannon_pistons_group`** (必须) 火炮的核心活塞元件编组名的标签
6. **`tag__cannon_releasers_group`** (必须) 火炮的释放和附着元件编组名的标签 (只支持转子)
7. **`tag__cannon_detachers_group`** (必须) 火炮的炮弹分离元件编组名的标签 (支持加特林, 合并块, 切割机)
8. **`tag__cannon_shell_warheads_group`** (可选) 火炮的弹头元件编组名的标签 (用于自动装备弹头)
9.  **`tag__cannon_shell_welders_group`** (可选) 火炮的焊接器元件编组名的标签 (用于自动开关焊接器)
10. **`tag__cannon_vertical_joints_group`** (可选) 火炮的垂直旋转关节元件编组名的标签 (用于自动开关关节锁定)
11. **`tag__postfix_cannon_status_indicator`** (可选) 火炮的活塞状态指示器的后缀
    ```
    将活塞编组中的某个活塞以该后缀命名后, 脚本会以该活塞的伸缩状态视作其所在火炮的活塞伸缩状态, 
    如果脚本找不以特定后缀命名的活塞, 就会自动从编组中随机选择 (列表第一个) 一个活塞作为状态指示器, 
    请注意, 若你的火炮是常规活塞火炮, 那么是不需要设置这一项的, 
    这里假设常规火炮的全部活塞状态总是一致 (一起伸展或收缩) (通常这是成立的), 
    但考虑到某些火炮(例如, 作者的某些火炮), 其可能存在状态完全相反的活塞, 
    此时, 脚本随机选择一个活塞作为指示器的方式就可能导致错误, 因此需设置此项
    ```
    
12. **`tag__custom_interface_timer_0`** (可选) 火炮的第一个用户自定义接口定时器名称的标签
    ```
    脚本会找到以此标签命名的定时器(请注意, 和诸如 tag__cannon_pistons_group 这种标签一样, 后面需要一个编号后缀), 
    在火炮开炮的合适阶段(你可以设置该时间)会自动触发该定时器一次, 以这种通用的方式, 
    你可以将一些你所需要的, 但是脚本未能提供的自定义动作放到这个定时器中, 完成你的特殊需求
    ```
    ```
    <举例> 
    比如你需要在火炮开炮的瞬间关闭一个室内灯, 在装填完毕后重新打开它(作为状态指示灯), 那么就需要用到此功能
    ```
    
13. **`tag__custom_interface_timer_1`** (可选) 火炮的第二个用户自定义接口定时器名称的标签
    ```
    和上一条相同, 不同的是, 这是第二个定时器接口, 此脚本一共提供两个用户自定义定时器接口
    ```
    
14. **`tag__info_display_LCD_group`** (可选) 脚本的信息显示LCD编组
15. **`flag__auto_activate_shell`** (功能开关) 自动激活炮弹(HE炮弹)
16. **`flag__auto_start_warhead_countdown`** (功能开关) 自动开启弹头倒计时
17. **`flag__auto_toggle_welders_onoff`** (功能开关) 自动开关焊接器
18. **`flag__auto_toggle_vertical_joints_lock`** (功能开关) 自动锁定解锁垂直关节
19. **`flag__auto_trigger_custom_interface_timer_0`** (功能开关) 自动触发第一个用户定时器接口
20. **`flag__auto_trigger_custom_interface_timer_1`** (功能开关) 自动触发第二个用户定时器接口
21. **`flag__auto_check`** (功能开关) 按指定频率定期执行自检
22. **`flag__auto_reload`** (功能开关) 在火炮出现异常时尝试复位(自动重载)
23. **`flag__reload_once_after_script_initialization`** (功能开关) 脚本初始化之后自动将所有火炮重载一次
    ```
    当编程块被生成时会初始化一次, 当 "重置代码" 按钮被触发时也会初始化一次.
    开启这个选项意味着, 当你从蓝图拉到世界里的时候, 火炮会重载一次. 该选项默认开启.
    ```

24. `flag__enable_two_stage_mode` (功能开关) 开启二段蓄力模式
    ```
    关于何为二段蓄力模式请咨询作者, 限于篇幅不在此赘述
    ```

25. `flag__synchronized_minor_pistons` (功能开关) 同步的次要活塞
    ```
    只有开启二段蓄力模式, 此开关才会出现并有意义
    ```

26. `flag__enable_shell_disconnection` (功能开关) 启用主动断开炮弹连接功能
    ```
    当且仅当使用活塞作为破限组件时, 此项才有意义, 否则此功能不生效
    开启此功能后, 脚本会尝试在一次射击之后主动断开与炮弹的连接
    ```

27. `flag__enable_shell_integrity_check` 启用炮弹完整性检查
    ```
    当且仅当主动断开炮弹连接功能生效时 (生效不同于开启), 此项才有意义, 否则此功能不生效
    开启此功能后, 脚本会在火炮释放时先进行一次网格层面的方块数量检查, 当且仅当方块数量与用户设置的值一致时, 
    脚本才会尝试释放并进行后续的动作, 否则将会进行等待, 一次等待一帧,
    最大等待次数可在下方的选项 times__max_delay 中配置
    ```

28. **`period__auto_check`** (周期, 整数) 自动检查周期
29. **`period__auto_fire`** (周期, 整数) 自动射击周期
30. **`period__update_output`** (周期, 整数) 更新脚本输出周期 (LCD, 编程块终端)(此值忌过小, 存在性能问题)
31. **`delay_release`** (延时, 整数) 火炮释放弹性势能的时刻
    ```
    在这一个动作, 如果开启了自动激活弹头功能, 那么脚本会开始尝试获取弹头对象.
    在这一个动作, 如果开启了自动锁定垂直关节功能, 那么脚本会锁定对应的转子或铰链.
    ```
     
32. **`delay__detach_begin`** (延时, 整数) 火炮开始准备进行炮弹分离的时刻
    ```
    若你的火炮采用加特林分离, 那么此时脚本会尝试打开加特林;
    若是切割机分离, 脚本会尝试打开切割机(此时切割机将开始切割);
    若是合并块分离, 脚本不会有任何动作
    ```
     
33. **`delay_detach`** (延时, 整数) 火炮进行炮弹分离的时刻
    ```
    若你的火炮采用加特林分离, 那么此时脚本会尝试让加特林射击一次;
    若是切割机分离, 脚本会尝试关闭切割机(并停止切割);
    若是合并块分离, 脚本会把合并块关闭以实现分离
    ```
     
34. **`delay__detach_end`** (延时, 整数) 火炮结束炮弹分离的时刻
    ```
    若你的火炮采用加特林分离, 那么此时脚本会尝试关闭加特林;
    若是切割机分离, 那么此时脚本不会有任何动作;
    若是合并块分离, 脚本会把合并块重新开启, 为下一轮焊接做准备
    ```

35. **`delay__try_activate_shell`** (延时, 整数) 脚本尝试激活炮弹的时刻
    ```
    在这一个动作, 如果开启了自动激活弹头功能, 那么脚本会开始尝试装备弹头.
    若指定了分离部件网格定位器, 那么此时脚本还会尝试检查以下两点:
    1. 弹头是否成功与定位器所在的网格分离
    2. 弹头与定位器之间的距离是否超过安全阈值
    只有当通过两个检查之后, 脚本才会装备弹头.
    若你的火炮采用加特林分离, 那么此时脚本不会有任何动作;
    若是切割机分离, 脚本不会有任何动作;
    若是合并块分离, 脚本会重新开启合并块, 为下一轮焊接做准备
    ```
     
36. **`delay__try_disconnect_shell`** (延时, 整数) 脚本尝试断开炮弹连接的时刻
    ```
    如果你的火炮支持主动断开炮弹网格连接(仅针对破限火炮), 并且在设置中开启了本脚本的此功能
    则在此时刻脚本会断开 (detach) 一个活塞的活塞头来主动切断与炮弹的网格 (子网格) 连接
    ```
     
37. **`delay__pistons_extend`** (延时, 整数) 火炮活塞伸展的时刻
    ```
    在这一个动作, 如果开启了自动开关焊接器, 那么脚本会尝试打开焊接器.
    ```
     
38. **`delay_attach`** (延时, 整数) 火炮机构附着的时刻
    ```
    在这一个动作, 如果开启了自动锁定垂直关节功能, 那么脚本会解锁对应的转子或铰链.
    注意若此步骤中释放器未能全部附着, 则再下一个时刻重新尝试直到全部附着.
    ```
     
39. **`dealy__pistons_retract`** (延时, 整数) 火炮活塞收缩(蓄力)的时刻
40. **`delay__custom_interface_timer_0`** (延时, 整数) 触发第一个用户自定义定时器的时刻
41. **`delay__custom_interface_timer_1`** (延时, 整数) 触发第二个用户自定义定时器的时刻
42. **`delay__done_loading`** (延时, 整数) 火炮装填完成的时刻
    ```
    在这一个动作, 如果开启了自动开关焊接器, 那么脚本会尝试关闭焊接器.
    ```
    
43. **`delay__first_reload`** (延时, 整数) 火炮第一次自动重载的延迟时间(此值必须为非负数)
44. **`delay_pausing`** (延时, 整数) 火炮重载过程中主活塞组伸展后的强制性暂停时间(此值必须为非负数)
     
45. **`distance__warhead_savety_lock`** (距离, 浮点数) 弹头安全锁距离
46. **`number__warhead_countdown_seconds`** (秒数, 浮点数) 弹头倒计时秒数
47. **`time__disconnecting_shell`** (时间, 整数) 断开炮弹连接耗时
48. **`count__total_blocks_in_detach_grid`** (计数, 整数) 分离件网格总方块数
    ```
    分离件网格一般成分: 合并块+活塞头+投影仪+炮弹方块
    ```

49. **`times__max_delay`** (计数, 整数) 最大延迟 (暂停) 次数 
    ```
    炮弹完整性检查不通过时会强制暂停一帧进行等待,
    这个变量控制最大等待次数, 若此值小于等于0, 则不进行任何等待, 立刻进行重载
    ```


## LCD配置

> 请在LCD的自定义数据中键入以下配置以显示不同的信息

|       指令       |                       功能说明                       |   参数   |    备注     |
| :--------------: | :--------------------------------------------------: | :------: | :---------: |
|    `general`     |       显示脚本运行状态信息和一些实用的统计信息       |    无    |             |
| (空, 什么都不写) |       显示脚本运行状态信息和一些实用的统计信息       |    无    | 同`general` |
|     `cannon`     |            显示编号为 `m`的火炮的详细信息            |   `m`    |             |
|     `cannon`     | 显示编号在 `m`(含) 到 `n`(含) 范围内的火炮的简略信息 | `m`, `n` |             |
|     `group`      |             显示编号为 `m` 的编组的信息              |   `m`    |             |
|     `group`      |   显示编号在 `m`(含) 到 `n`(含) 范围内的编组的信息   | `m`, `n` |             |

注: 
1. 若在以上指令末尾添加 "graphic"(空格分隔), 脚本将以图形方式显示信息  
   只有以上 3, 4 条目的配置支持图形信息显示
2. 若脚本发现非法的LCD自定义数据, 将会显示错误信息
3. 如果是驾驶舱, 编程块, 等等这类可提供多个显示器的方块, 配置方法基本一致:  
   先将这些方块编入组, 之后在其CD (CustomData) 同样填写以上信息,  
   唯一的区别是在以上信息的前面需要额外增加一个整数 (空格分隔) 用于指示显示屏的索引,  
   如果需要这类方块提供的多个显示器, 换行写下一条即可.  
   如果你不知道显示屏索引是多少, 解决方法如下:  
   通常此类方块的终端中包含显示器的列表, 这个列表视按照编号升序排列的 (从0开始计数)  
4. 指令后如果需要带参数请使用空格进行分隔, 如有多个参数每个参数之间都需要至少一个空格


## 信息显示

> 这个部分我懒得写了, 请自行尝试理解一下脚本的各种信息输出


## 注意事项

1. **修改脚本的任何配置选项之后, 请重置代码一次来应用这些更改** (请务必留意).
2. 出于某些需要, 此脚本的刷新频率是固定**每帧一次**.
3. **不建议修改脚本代码内容**, 以免出现故障和异常 (代码含有注释, 有能力可自行修改).
4. 关于脚本的 **`组间射击模式`** 和 **`组内射击模式`**
   1. 组内射击模式是指脚本如何控制一个火炮编组内全部火炮进行射击的模式,  
        若设为轮射, 则当脚本尝试射击一个编组时, 会选择其中一根装填完毕的火炮进行射击;  
        若设为齐射, 则当脚本尝试射击一个编组时, 其中所有装填完毕的火炮都会进行射击.  
   2. 组间射击模式是指脚本如何控制各个火炮编组进行射击的模式,  
        若设为轮射, 则当脚本射击时, 会选择一个编组进行射击, 要求组内至少存在一门装填完毕的火炮;  
        若设为齐射, 则当脚本射击时, 会让所有编组进行射击 (若编组内不存在装填完毕的火炮也不会射击).  


## 更新日志

```
========== V0.2.0 ==========
新功能
1. 添加炮弹(分离)网格的完整度识别, 以彻底避免因炮弹未焊接完全而导致的火炮故障
常规更新
1. 调整代码结构, 去除冗余代码并修正错误
2. 脚本的默认编组名较之前的版本进行了更改

========== V0.1.8 ==========
常规更新
1. 修正了重载机制中的一些错误
额外消息
1. 下个版本号是 V0.2.0, 将会添加投影仪焊接的完整度识别, 以阻止因炮弹不能正常焊接而导致的火炮故障

========== V0.1.7 ==========
常规更新
1. 修改了火炮重载机制, 更加智能化

========== V0.1.6 ==========
新功能
1. 新增了多个脚本运行参数, 用于强制让脚本按某种模式进行射击
常规更新
1. 修复了上个版本中火炮附着机制的BUG
2. 修正了脚本对炮弹断开连接功能支持的缺陷, 添加了新的选项
3. 完善了脚本对火炮状态及完整度的检查机制, 现在可以更准确地识别火炮的故障情况
4. 代码结构微调和优化

========== V0.1.5 ==========
新功能
1. 对于二段式火炮提供了机械连接方块 (转子铰链活塞悬架) 固定方式的支持
2. 对于机械连接方块, 现在此脚本会持续检查附着是否成功, 若未成功则会在下一帧继续尝试
常规更新
1. 修复了火炮对象构建执行二段式火炮相关初始化时使用了错误的列表的问题
2. 为驾驶舱, 编程块等这类可提供多个显示器 (或一个) 的方块提供了支持
3. 代码微调和优化

========== V0.1.4 ==========
新功能
1. 为新式破限部件提供新的功能: 立刻断开炮弹网格连接, 以移除炮弹对主体的质心影响
常规更新
1. 修复了自动关闭分离器的BUG(脚本应仅在加特林分离模式和焊接器分离模式执行此步骤)
2. 代码微调和优化

========== V0.1.3 ==========
新功能
1. 为脚本新增了强制自检指令 "check_cannons_status" (大部分情况下无需使用此指令)
2. 为火炮对象的自动检查添加了新的逻辑, 自检时如果火炮处于"就绪"状态且分离器开启则将其关闭(仅适用于加特林)
常规更新
1. 修复了以加特林为分离器的火炮射击流程中无法自动关闭加特林的BUG
2. 代码微调和优化

========== V0.1.2 ==========
新功能
1. 新增了第一次重载延迟, 可以更好地兼容二段式火炮
常规更新
1. 修复了二段式火炮状态检测的BUG
2. 更换了新的配置模块, 使用全新的动态配置功能
3. 代码优化, 增强了二段式火炮的兼容性

========== V0.1.1 ==========
新功能
1. 现在可以让脚本在初始化后自动对火炮进行一次重载 (重装填). 此功能默认开启但可关闭.
    注: "初始化" 过程发生在编程块在世界中被创建, 或玩家手动点击 "重置脚本" 按钮时.
常规更新
1. 修改了重载机制, 微调了代码结构

========== V0.1.0 ==========
新功能
1. 找到了转子状态异常BUG的起因, 并在脚本中针对性地进行了修复, 现在不会再次出现无法装填的故障.
    注: 出现BUG并不是脚本的原因, 是傻逼K社的游戏BUG, 与本人和此脚本无关. 
        另外, 现在你可以肆无忌惮地开启脚本的图形界面功能了.
2. 为新式的二段蓄力火炮提供支持, 限于篇幅有关内容不在此说明, 如需使用此功能请联系作者. 
3. 脚本通用配置代码中添加显示标题的功能, 现在编程块的CD配置更加直观友好.
常规更新
1. 现在脚本会在活塞收缩之前检查是否成功附着, 未能附着时会尝试重新附着.
额外消息
1. 这是自脚本发布以来最为重要的一次更新! 请尽量避免使用 V0.1.0 之前的老版本.

========== V0.0.5 ==========
常规更新
1. 炮弹激活现在不再和 "分离结束" (delay__detach_end) 绑定.
2. 新增了单独编组射击命令 "fire_specific_group", 后跟目标编组号 (用空格分开).
3. 出于优化考虑不再为每个弹头检查保险, 并进行了一些其它的脚本优化.
4. 优化了LCD字符信息显示, 现在火炮的简略信息会用字符的形式显示进度条.

========== V0.0.4 ==========
常规更新
1. 使用了新的(重写的)脚本配置通用代码,
    现在会在编程块命令行底端显示脚本配置中出现的错误.
2. 编程块输出信息格式微调, 现在会显示脚本版本.
3. 脚本代码微调, 删掉了部分多余的代码, 和不优雅的结构.
额外消息
1. 最新的SE疑似修复了转子BUG, 现在你可以尝试开启图形化信息显示功能,
    如果出现意外情况请你关闭此功能.

========== V0.0.3 ==========
新功能
1. 增加了LCD图形化信息显示 (会增加CPU和显卡的负担, 不推荐使用).
常规更新
1 优化了代码结构.
已知问题
1. 疑似在游戏卡顿(脚本卡顿)的情况下, 容易导致火炮的分离转子出现BUG状态, 
    目前, 出现这种现象的原因尚不明, 极有可能是SE的BUG, 
    我花了很长时间仔细查看与转子有关的接口, 都未能发现脚本的任何问题.

========== V0.0.2 ==========
常规更新
1. 现在会为每一个弹头检查保险.

========== V0.0.1 ==========
新功能
1. 新增了自动开启炮弹弹头倒计时的功能, 可在选项中关闭此功能 (默认开启).

========== V0.0.0 ==========
初始版本, 包含基础功能
```


## 实用参数记录
```
========== 1.8秒装填参数 ==========
delay_release = 1
delay__detach_begin = 1
delay_detach = 2
delay__detach_end = 10
delay__try_activate_shell = 5
delay__pistons_extend = 3
delay_attach = 30
dealy__pistons_retract = 86
delay__custom_interface_timer_0 = 1
delay__custom_interface_timer_1 = 108
delay__done_loading = 108
```